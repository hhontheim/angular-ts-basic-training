<!-- <aside style="position: absolute; top: 0px; right: 0px;" data-controls-layout>Typescript Handy On</aside> -->
<section>
    <h2>Setup</h2>
    <p>Setup VSCODE: Install Extensions: TODO</p>
    <pre><code>npm i --save-dev typescript</code></pre>
    <pre><code>npm install -g typescript</code></pre>
    <p class="fragment">Global installierte Module sind automatisch in der Path Umgebungsvariable. Das tsc Kommando
        wird in der Shell verfügbar.</p>
    <p class="fragment">tsc vs npm run tsc</p>
</section>
<section>
    <h2>Typescript Hands On</h2>
    <p>Wir testen den Typescript Compiler.</p>
    <pre><code>echo console.log('hello world') >> helloworld.ts</code></pre>
    <pre><code>tsc helloworld.ts</code></pre>
    <pre><code data-trim data-noescape>node helloworld.js</code></pre>
</section>
<section>
    <p>Wir initialiseieren ein Typescript Projekt mit Typescript Compiler.</p>
    <pre><code>tsc --init</code></pre>
    <p>Verzeichnis 'src' erstellen und helloword.ts hinein verschieben.</p>
    <pre><code>"rootDir": "./src",</code></pre>
    <pre><code>"outDir": "./out",</code></pre>
    <pre><code>tsc</code></pre>
</section>
<section>
    <h2>Basic Types</h2>
    <h4>Boolean</h4>
    <pre><code>let isDone: boolean = false;</code></pre>
    <h4>Number</h4>
    <pre><code  class="typescript" data-trim data-noescape>
                let decimal: number = 6; 
                let hex: number = 0xf00d; 
                let binary: number = 0b1010; 
                let octal: number = 0o744;
            </code></pre>
    <h4>String</h4>
    <pre><code class="typescript" data-trim data-noescape>
                let color: string = "blue";
                color = 'red';
                let age: number = 37;
                let sentence: string = `Hello, my name is ${ fullName }.
                I'll be ${ age + 1 } years old next month.`;
            </code></pre>
</section>
<section>
    <h4>Array</h4>
    <pre><code>let list: number[] = [1, 2, 3];</code></pre>
    <pre><code class="typescript">let list: Array&lt;number> = [1, 2, 3];</code></pre>
    <h4>Tuple</h4>
    <pre><code data-trim data-noescape>
            let x: [string, number];
            // Initialize it
            x = ["hello", 10]; // OK
            // Initialize it incorrectly
            x = [10, "hello"]; // Error
            </code></pre>
    <h4>Enum</h4>
    <pre><code data-trim data-noescape>
                    enum Color {Red, Green, Blue}
                    let c: Color = Color.Green;
            </code></pre>
</section>
<section>
    <h5>Any</p>
        <pre><code>let list: any[] = [1, true, "free"];</code></pre>
        <h5>Unkown</h5>
        <pre><code data-trim data-noescape>
                    let someValue: unknown = "this is a string";
                    if (typeof someValue === 'string') {
                        let strLength: number = (&lt;string>someValue).length;
                    }
            </code></pre>
        <h5>Void</h5>
        <pre><code data-trim data-noescape>
                function warnUser(): void {
                    console.log("This is my warning message");
                }</code></pre>
        <h5>Never</h5>
        <pre><code data-trim data-noescape>
                function error(message: string): never {
                    throw new Error(message);
                }
                </code></pre>
</section>
<section>
    <h5>Undefined, Null</h5>
    <pre><code class="typescript">function doSomething(param: string | null | undefined): void</code></pre>
    <h5>Object</h5>
    <p>Object ist ein nicht primitiver Typ, also alles was nicht number, string, boolean,
        symbol, null, oder undefined ist.</p>
    <pre><code>declare function create(o: object | null): void;
                </code></pre>
    <pre><code>declare function create(o: {} | null): void;
                    </code></pre>
</section>
<section>
    <h2>Type Assertions</h2>
    <pre><code>let strLength: number = (&lt;string>someValue).length;</code></pre>
    <pre><code>let strLength: number = (someValue as string).length;</code></pre>
</section>
<section>
    <h2>Undefined & null Prüfung</h2>
    <pre><code data-trim data-noescape>
        function nullcheck(param: { property: string }) {
            if(param !== null && param !== undefined){
                if(param.property !== null && 
                param.property !== undefined){
                    // NOOOOO
                }
            }
            if(param && param.property){
                // string
            }
            if(!!(param && param.property)){
                // boolean
            }
        }
    </code></pre>
    <p>!! Operator: "bang, bang you're boolean" </p>
</section>
<section>
    <h2>Variable Declarations</h2>
    <pre><code>var a = 10;</code></pre>
    <pre><code data-trim data-noescape>
        const b = 'hello';
        b += 'world'; // error
    </code></pre>
    <p>var scoping</p>
    <pre><code data-trim data-noescape>
        function f(shouldInitialize: boolean) {
            var x;
            if (shouldInitialize) {
                x = 10;
            }
            return x;
        }
        console.log(f(true)); // returns '10'
        console.log(f(false)); // returns 'undefined'                          
    </code></pre>
    <pre><code>f(true);  // returns '10'</code></pre>
    <pre><code>f(false); // returns 'undefined'</code></pre>
</section>
<section>
    <h4>const</h4>
    <p>const sorgt <b>nicht</b> für Immutablitity</p>
    <pre><code data-trim data-noescape>
        const numLivesForCat = 9;
        const kitty = {
            name: "Aurora",
            numLives: numLivesForCat,
        }
        kitty = {// Error
            name: "Danielle",
            numLives: numLivesForCat
        };
        // all "okay"
        kitty.name = "Rory";
        kitty.name = "Kitty";
        kitty.name = "Cat";
        kitty.numLives--;
    </code></pre>
</section>
<section>
    <p>Wo ist der Fehler?</p>
    <pre><code data-trim data-noescape>
        function sumMatrix(matrix: number[][]) {
            var sum = 0;
            for (var i = 0; i &lt; matrix.length; i++) {
                var currentRow = matrix[i];
                for (var i = 0; i &lt; currentRow.length; i++) {
                    sum += currentRow[i];
                }
            }
            return sum;
        }
    </code></pre>
</section>
<section>
    <p>Was ist das Ergebnis auf der Console?</p>
    <pre><code data-trim data-noescape>
        for (var i = 0; i &lt; 10; i++) {
            setTimeout(function() { console.log(i); }, 100 * i);
        }
    </code></pre>
</section>
<section>
    <h2>Destructing Arrays</h2>
    <pre><code data-trim data-noescape>
            let [first, ...rest] = [1, 2, 3, 4];
            console.log(first); // outputs 1
            console.log(rest); // outputs [ 2, 3, 4 ]
    </code></pre>
    <h2>Destructing Objects</h2>
    <pre><code data-trim data-noescape>
            let o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            let { a, b } = o;
    </code></pre>
</section>
<section>
    <h2>Spread Operator</h2>
    <pre><code data-trim data-noescape>
        let first = [1, 2];
        let second = [3, 4];
        let bothPlus = [0, ...first, ...second, 5];
    </code></pre>
</section>
<section>
    <h2>Interfaces</h2>
    <p>Explizit definierte Typen</p>
    <pre><code data-trim data-noescape>
            function printLabel(labelledObj: { label: string }) {
                console.log(labelledObj.label);
            }
            
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
    </code></pre>
    <pre><code data-trim data-noescape>
            interface LabelledValue {
                label: string;
                readonly optional?: boolean;
            }
            
            function printLabel(labelledObj: LabelledValue) {
                console.log(labelledObj.label);
            }
            
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
    </code></pre>
    <p>Was macht der Compiler mit Interfaces?</p>
</section>
<section>
    <h2>Readonly</h2>
    <ul>
        <li>Variables: const</li>
        <li>Properties: readonly</li>
        <li>ReadonlyArray:</li>
    </ul>
    <pre><code data-trim data-noescape>
            let a: number[] = [1, 2, 3, 4];
            let ro: ReadonlyArray&lt;number> = a;
            ro[0] = 12; // error!
            ro.push(5); // error!
            ro.length = 100; // error!
            a = ro; // error!
    </code></pre>
</section>

<section>
    <h2>Klassen</h2>
    <p>Constructor Parameter werden automatisch zu Properties, mit einem Zugriffsmodifier oder readonly.</p>
    <pre><code data-trim data-noescape>
        class DigitalClock implements ClockInterface {
            constructor(public h: number, public m: number) {}
            tick() {
                console.log('beep beep');
            }
        }
    </code></pre>
    <pre><code data-trim data-noescape>
            get fullName(): string {
                return this._fullName;
            }
            set fullName(newName: string) {
                if (passcode && passcode == "secret passcode") {
                    this._fullName = newName;
                }
            }
            //
            employee.fullName = "Bob Smith";
            console.log(employee.fullName);
        </code></pre>
</section>
<section>
    <h2>Funktionen</h2>
    <p>Unterschied zu JS: Signatur.</p>
    <pre><code data-trim data-noescape>
    function add(x: number, y: number): number {
        return x + y;
    }
    let myAdd: (x: number, y: number) => number = (x, y) => {
        return x + y;
    };
    </code></pre>
    <p>Optional Parameter: </p>
    <pre><code>function buildName(firstName: string, lastName?: string) {</code></pre>
    <p>Default Parameter: </p>
    <pre><code> function buildName(firstName: string, lastName = 'Smith') {</code></pre>
    <p>Rest Parameter: </p>
    <pre><code>function buildName(firstName: string, ...restOfName: string[]) {</code></pre>
</section>
<section>
    <h2>this and arrow functions</h2>
    <p>In JavaScript ist <i>this</i> eine Variable, die gesetzt wird, wenn eine Funktion aufgerufen wird. </p>
    <p>Arrow Funktionen setzen <i>this</i> dort, wo die Funktion erzeugt wird.</p>
</section>
<section>
    <h2>Generics</h2>
    <p>Function Signature</p>
    <pre><code>function create&lt;T>(c: {new(): T; }): T {</code></pre>
    <p>Function Signature</p>
    <pre><code>function getProperty&lt;T, K extends keyof T>(obj: T, key: K) {</code></pre>
    <p>Generic Classes</p>
    <pre><code>
        class GenericNumber&lt;T> {
            zeroValue: T;
            add: (x: T, y: T) => T;
        }
    </code></pre>
</section>
<section>
    <h2>Enums</h2>
    <p>Numeric Enums</p>
    <pre><code data-trim data-noescape>
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }
    </code></pre>
    <p>String Enums</p>
    <pre><code data-trim data-noescape>
        enum Direction {
            Up = "UP",
            Down = "DOWN",
            Left = "LEFT",
            Right = "RIGHT",
        }
    </code></pre>
</section>
<section>
    <h2>Type Inference</h2>
    <p>Best common type</p>
    <pre><code>let x = [0, 1, null];</code></pre>
    <pre><code>number | null</code></pre>
    <p>Contextual Type</p>
    <pre><code>function createZoo(): Animal[] {
        return [new Rhino(), new Elephant(), new Snake()];
    }</code></pre>
    <pre><code>Animal</code></pre>
</section>
<section>
    <h2>Type Compatibility</h2>
    <p>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types
        based solely on their members. This is in contrast with nominal typing. Consider the following code:</p>
    <pre><code data-trim data-noescape>
        interface Named {
            name: string;
        }
    
        class Person {
            name: string;
        }
        let p: Named;
        // OK, because of structural typing
        p = new Person();",
        }
    </code></pre>
</section>
<section>
    <h2>Type Compatibility contd.</h2>
    <pre><code data-trim data-noescape>
            let x = (a: number) => 0;
            let y = (b: number, s: string) => 0;
            
            y = x; // OK
            x = y; // Error
    </code></pre>
</section>
<section>
    <h2>Advanced Types</h2>
    <p>Intersection</p>
    <pre><code>function extend&lt;T, U>(first: T, second: U): T & U {</code></pre>
    <p>Union Types</p>
    <pre><code>function padLeft(value: string, padding: string | number) {</code></pre>
    <p>Type Guards</p>
    <pre><code>
        function isFish(pet: Fish | Bird): pet is Fish {
            return (&lt;Fish>pet).swim !== undefined;
        }</code></pre>
</section>
<section>
    <p>typeof type guards: primitive Types</p>
    <p>instanceof type guards: Objects</p>
    <p>Nullable types: Union with null</p>
</section>
<section>
    <h2>Symbols</h2>
    Symbols are immutable, and unique.
    <pre><code data-trim data-noescape>
    let sym2 = Symbol("key");
    let sym3 = Symbol("key");
    sym2 === sym3; // false, symbols are unique
</code></pre>
    <p>Just like strings, symbols can be used as keys for object properties.</p>
</section>
<section>
    <h2>Iterators and Generators</h2>
    <p>values: for..of (Iterator Types. Will be different in ES3 and ES5)</p>
    <p>keys: for..in Objects and Iterator Types</p>
</section>
<section>
    <h2>Modules</h2>
    <p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a
        module. Conversely, a file without any top-level import or export declarations is treated as a script whose
        contents are available in the global scope (and therefore to modules as well).</p>
    <p>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the
        export keyword.</p>
</section>
<section>
    <pre><code>
        class ZipCodeValidator implements StringValidator {
            isAcceptable(s: string) {
                return s.length === 5 && numberRegexp.test(s);
            }
        }
        export { ZipCodeValidator };
        export { ZipCodeValidator as mainValidator };
    </code></pre>
    <pre><code>import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";</code></pre>
    <pre><code>import * as validator from "./ZipCodeValidator";
        let myValidator = new validator.ZipCodeValidator();
        Import a module for side-effects only</code></pre>
</section>
<section>
    <pre><code data-trim data-noescape>
        //ZipCodeValidator.ts
        export default class ZipCodeValidator {
            static numberRegexp = /^[0-9]+$/;
            isAcceptable(s: string) {
                return s.length === 5 && 
                    ZipCodeValidator.numberRegexp.test(s);
            }
        }
        //Test.ts
        import validator from "./ZipCodeValidator";
        let myValidator = new validator();
    </code></pre>
</section>
<section>
    <h2>export = and import = require()</h2>
    <p>oth CommonJS and AMD generally have the concept of an exports object which contains all exports from a module.

        They also support replacing the exports object with a custom single object. Default exports are meant to act as
        a replacement for this behavior; however, the two are incompatible. TypeScript supports export = to model the
        traditional CommonJS and AMD workflow.

        The export = syntax specifies a single object that is exported from the module. This can be a class, interface,
        namespace, function, or enum.

        When exporting a module using export =, TypeScript-specific import module = require("module") must be used to
        import the module.</p>
</section>
<section>
    <h2>Working with Other JavaScript Libraries></h2>
    <p> To describe the shape of libraries not written in TypeScript, we need to declare the API that the library
        exposes.

        We call declarations that don’t define an implementation “ambient”. Typically, these are defined in .d.ts
        files. If
        you’re familiar with C/C++, you can think of these as .h files. Let’s look at a few examples.
    </p>
</section>
<section>
    <h2>Namespaces</h2>
    <p>Ähnlich zu packages in javascript.</p>
    <pre><code>
        namespace Shapes {
            export namespace Polygons {
                export class Triangle { }
                export class Square { }
            }
        }
        import polygons = Shapes.Polygons;
        let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'</code></pre>
</section>
<!-- <section>
    <h2>Namespaces and Modules</h2>
</section> -->
<!-- <section>
    <h2>Module Resolution</h2>
</section> -->
<section>
    <h2>Declaration Merging</h2>
</section>
<section>
    <h2>JSX</h2>
</section>
<section>
    <h2>Decorators</h2>
</section>
<section>
    <h2>Mixins</h2>
</section>
<section>
    <h2>Triple-Slash Directives</h2>
</section>
<section>
    <h2>Type Checking JavaScript Files</h2>
</section>