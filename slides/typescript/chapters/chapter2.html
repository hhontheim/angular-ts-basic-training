<!-- <aside style="position: absolute; top: 0px; right: 0px;" data-controls-layout>Typescript Handy On</aside> -->
<section>
    <h2>Setup</h2>
    <p>Setup VSCODE: Install Extensions: tslint</p>
    <pre><code>npm i --save-dev typescript</code></pre>
    <pre><code>npm install -g typescript</code></pre>
    <p class="fragment">Global installierte Module sind automatisch in der Path Umgebungsvariable. Das tsc Kommando
        wird in der Shell verfügbar.</p>
    <p class="fragment">tsc vs npm run tsc</p>
</section>
<section>
    <h2>Typescript Hands On</h2>
    <p>Wir testen den Typescript Compiler.</p>
    <pre><code>echo console.log('hello world') >> helloworld.ts</code></pre>
    <pre><code>tsc helloworld.ts</code></pre>
    <pre><code data-trim data-noescape>node helloworld.js</code></pre>
</section>
<section>
    <p>Wir initialiseieren ein Typescript Projekt mit Typescript Compiler.</p>
    <pre><code>tsc --init</code></pre>
    <p>Verzeichnis 'src' erstellen und helloword.ts hinein verschieben.</p>
    <pre><code>"rootDir": "./src",</code></pre>
    <pre><code>"outDir": "./out",</code></pre>
    <pre><code>tsc</code></pre>
</section>
<section>
    <h2>Basic Types</h2>
    <h4>Boolean</h4>
    <pre><code>let isDone: boolean = false;</code></pre>
    <h4>Number</h4>
    <pre><code  class="typescript" data-trim data-noescape>
                let decimal: number = 6; 
                let hex: number = 0xf00d; 
                let binary: number = 0b1010; 
                let octal: number = 0o744;
            </code></pre>
    <h4>String</h4>
    <pre><code class="typescript" data-trim data-noescape>
                let color: string = "blue";
                color = 'red';
                let age: number = 37;
                let sentence: string = `Hello, my name is ${ fullName }.
                I'll be ${ age + 1 } years old next month.`;
            </code></pre>
</section>
<section>
    <h4>Array</h4>
    <pre><code>let list: number[] = [1, 2, 3];</code></pre>
    <pre><code class="typescript">let list: Array&lt;number> = [1, 2, 3];</code></pre>
    <h4>Tuple</h4>
    <pre><code data-trim data-noescape>
            let x: [string, number];
            // Initialize it
            x = ["hello", 10]; // OK
            // Initialize it incorrectly
            x = [10, "hello"]; // Error
            </code></pre>
    <h4>Enum</h4>
    <pre><code data-trim data-noescape>
                    enum Color {Red, Green, Blue}
                    let c: Color = Color.Green;
            </code></pre>
</section>
<section>
    <h5>Any</p>
        <pre><code>let list: any[] = [1, true, "free"];</code></pre>
        <h5>Unkown</h5>
        <pre><code data-trim data-noescape>
                    let someValue: unknown = "this is a string";
                    if (typeof someValue === 'string') {
                        let strLength: number = (&lt;string>someValue).length;
                    }
            </code></pre>
        <h5>Void</h5>
        <pre><code data-trim data-noescape>
                function warnUser(): void {
                    console.log("This is my warning message");
                }</code></pre>
        <h5>Never</h5>
        <pre><code data-trim data-noescape>
                function error(message: string): never {
                    throw new Error(message);
                }
                </code></pre>
</section>
<section>
    <h5>Undefined, Null</h5>
    <pre><code class="typescript">function doSomething(param: string | null | undefined): void</code></pre>
    <h5>Object</h5>
    <p>Object ist ein nicht primitiver Typ, also alles was nicht number, string, boolean,
        symbol, null, oder undefined ist.</p>
    <pre><code>declare function create(o: object | null): void;
                </code></pre>
    <pre><code>declare function create(o: {} | null): void;
                    </code></pre>
</section>
<section>
    <h2>Type Assertions</h2>
    <pre><code>let strLength: number = (&lt;string>someValue).length;</code></pre>
    <pre><code>let strLength: number = (someValue as string).length;</code></pre>
</section>
<section>
    <h2>Undefined & null Prüfung</h2>
    <pre><code data-trim data-noescape>
        function nullcheck(param: { property: string }) {
            if(param !== null && param !== undefined){
                if(param.property !== null && 
                param.property !== undefined){
                    // NOOOOO
                }
            }
            if(param && param.property){
                // string
            }
            if(!!(param && param.property)){
                // boolean
            }
        }
    </code></pre>
    <p>!! Operator: "bang, bang you're boolean" </p>
</section>
<section>
    <h2>Variable Declarations</h2>
    <pre><code>var a = 10;</code></pre>
    <pre><code data-trim data-noescape>
        const b = 'hello';
        b += 'world'; // error
    </code></pre>
    <p>var scoping</p>
    <pre><code data-trim data-noescape>
        function f(shouldInitialize: boolean) {
            var x;
            if (shouldInitialize) {
                x = 10;
            }
            return x;
        }
        console.log(f(true)); // returns '10'
        console.log(f(false)); // returns 'undefined'                          
    </code></pre>
    <pre><code>f(true);  // returns '10'</code></pre>
    <pre><code>f(false); // returns 'undefined'</code></pre>
</section>
<section>
    <h4>const</h4>
    <p>const sorgt <b>nicht</b> für Immutablitity</p>
    <pre><code data-trim data-noescape>
        const numLivesForCat = 9;
        const kitty = {
            name: "Aurora",
            numLives: numLivesForCat,
        }
        kitty = {// Error
            name: "Danielle",
            numLives: numLivesForCat
        };
        // all "okay"
        kitty.name = "Rory";
        kitty.name = "Kitty";
        kitty.name = "Cat";
        kitty.numLives--;
    </code></pre>
</section>
<section>
    <p>Wo ist der Fehler?</p>
    <pre><code data-trim data-noescape>
        function sumMatrix(matrix: number[][]) {
            var sum = 0;
            for (var i = 0; i &lt; matrix.length; i++) {
                var currentRow = matrix[i];
                for (var i = 0; i &lt; currentRow.length; i++) {
                    sum += currentRow[i];
                }
            }
            return sum;
        }
    </code></pre>
</section>
<section>
    <p>Was ist das Ergebnis auf der Console?</p>
    <pre><code data-trim data-noescape>
        for (var i = 0; i &lt; 10; i++) {
            setTimeout(function() { console.log(i); }, 100 * i);
        }
    </code></pre>
</section>
<section>
    <h2>Destructing Arrays</h2>
    <pre><code data-trim data-noescape>
            let [first, ...rest] = [1, 2, 3, 4];
            console.log(first); // outputs 1
            console.log(rest); // outputs [ 2, 3, 4 ]
    </code></pre>
    <h2>Destructing Objects</h2>
    <pre><code data-trim data-noescape>
            let o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            let { a, b } = o;
    </code></pre>
</section>
<section>
    <h2>Spread Operator</h2>
    <pre><code data-trim data-noescape>
        let first = [1, 2];
        let second = [3, 4];
        let bothPlus = [0, ...first, ...second, 5];
    </code></pre>
</section>
<section>
    <h2>Interfaces</h2>
    <p>Explizit definierte Typen</p>
    <pre><code data-trim data-noescape class="typescript">
            function printLabel(labelledObj: { label: string }) {
                console.log(labelledObj.label);
            }
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
            interface LabelledValue {
                label: string;
                readonly optional?: boolean;
            }
            
            function printLabel(labelledObj: LabelledValue) {
                console.log(labelledObj.label);
            }
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
    </code></pre>
    <p>Was macht der Compiler mit Interfaces?</p>
</section>
<section>
    <h2>Readonly</h2>
    <ul>
        <li>Variables: const</li>
        <li>Properties: readonly</li>
        <li>ReadonlyArray:</li>
    </ul>
    <pre><code data-trim data-noescape>
            let a: number[] = [1, 2, 3, 4];
            let ro: ReadonlyArray&lt;number> = a;
            ro[0] = 12; // error!
            ro.push(5); // error!
            ro.length = 100; // error!
            a = ro; // error!
    </code></pre>
</section>
<section>
    <h2>Klassen</h2>
    <p>Constructor Parameter werden automatisch zu Properties, mit einem Zugriffsmodifier oder readonly.</p>
    <pre><code data-trim data-noescape>
        class DigitalClock implements ClockInterface {
            constructor(public h: number, public m: number) {}
            tick() {
                console.log('beep beep');
            }
        }
    </code></pre>
    <pre><code data-trim data-noescape>
            get fullName(): string {
                return this._fullName;
            }
            set fullName(newName: string) {
                if (passcode && passcode == "secret passcode") {
                    this._fullName = newName;
                }
            }
            employee.fullName = "Bob Smith";
            console.log(employee.fullName);
        </code></pre>
</section>
<section>
    <h2>Funktionen</h2>
    <p>Unterschied zu JS: Signatur.</p>
    <pre><code data-trim data-noescape>
    function add(x: number, y: number): number {
        return x + y;
    }
    let myAdd: (x: number, y: number) => number = (x, y) => {
        return x + y;
    };
    type functionType = (x: number, y: number) => number;
    let myAdd: functionType = (x, y) => {
        return x + y;
    };
    </code></pre>
</section>
<section>
    <p>Optional Parameter: </p>
    <pre><code>function buildName(firstName: string, lastName?: string) {</code></pre>
    <p>Default Parameter: </p>
    <pre><code> function buildName(firstName: string, lastName = 'Smith') {</code></pre>
    <p>Rest Parameter: </p>
    <pre><code>function buildName(firstName: string, ...restOfName: string[]) {</code></pre>
</section>
<section>
    <h2>this and arrow functions</h2>
    <p>In JavaScript ist <i>this</i> eine Variable, die gesetzt wird, wenn eine Funktion aufgerufen wird. </p>
    <p>Arrow Funktionen setzen <i>this</i> dort, wo die Funktion erzeugt wird.</p>
</section>
<section>
    <h2>Generics</h2>
    <p>Function Signature</p>
    <pre><code>function create&lt;T>(c: {new(): T; }): T {</code></pre>
    <p>Function Signature</p>
    <pre><code>function getProperty&lt;T, K extends keyof T>(obj: T, key: K) {</code></pre>
    <p>Generic Classes</p>
    <pre><code>
        class GenericNumber&lt;T> {
            zeroValue: T;
            add: (x: T, y: T) => T;
        }
    </code></pre>
</section>
<section>
    <h2>Enums</h2>
    <p>Numeric Enums</p>
    <pre><code data-trim data-noescape>
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }
    </code></pre>
    <p>String Enums</p>
    <pre><code data-trim data-noescape>
        enum Direction {
            Up = "UP",
            Down = "DOWN",
            Left = "LEFT",
            Right = "RIGHT",
        }
    </code></pre>
</section>
<section>
    <h2>Type Inference</h2>
    <p>Best common type</p>
    <pre><code>let x = [0, 1, null];</code></pre>
    <pre><code>number | null</code></pre>
    <p>Contextual Type</p>
    <pre><code>function createZoo(): Animal[] {
        return [new Rhino(), new Elephant(), new Snake()];
    }</code></pre>
    <pre><code>Animal</code></pre>
</section>
<section>
    <h2>Type Compatibility</h2>
    <p>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types
        based solely on their members. This is in contrast with nominal typing. Consider the following code:</p>
    <pre><code data-trim data-noescape>
        interface Named {
            name: string;
        }
    
        class Person {
            name: string;
        }
        let p: Named;
        // OK, because of structural typing
        p = new Person();",
        }
    </code></pre>
</section>
<section>
    <h2>Type Compatibility contd.</h2>
    <pre><code data-trim data-noescape>
            let x = (a: number) => 0;
            let y = (b: number, s: string) => 0;
            
            y = x; // OK
            x = y; // Error
    </code></pre>
</section>
<section>
    <h2>Advanced Types</h2>
    <p>Intersection</p>
    <pre><code data-trim data-noescape>function extend&lt;T, U>(first: T, second: U): T & U {</code></pre>
    <p>Union Types</p>
    <pre><code data-trim data-noescape>function padLeft(value: string, padding: string | number) {</code></pre>
    <p>Type Guards</p>
    <pre><code data-trim data-noescape>
    function isFish(pet: Fish | Bird): pet is Fish {
        return (&lt;Fish>pet).swim !== undefined;
    }
    </code></pre>
</section>
<section>
    <h2>Advanced Types Cont.</h2>
    <p>typeof type guards: primitive Types</p>
    <p>instanceof type guards: objects</p>
    <p>Nullable types: Union mit null</p>
</section>
<section>
    <h2>Symbols</h2>
    Symbols sind immutable, und unique.
    <pre><code data-trim data-noescape>
    let sym2 = Symbol("key");
    let sym3 = Symbol("key");
    sym2 === sym3; // false
</code></pre>
    <p>Wie strings, können symbols als Keys für object properties genutzt werden.</p>
</section>
<section>
    <h2>Iterators und Generators</h2>
    <p>values: for..of (Iterator Types. Unterschiedlicher Compiler-Output mit ES3 und ES5)</p>
    <p>keys: for..in Objects und Iterator Types</p>
    <pre><code data-trim data-noescape>
    for (let i in list28) {
        console.log(i); // "0", "1", "2",
    }
    for (let i of list28) {
        console.log(i); // "4", "5", "6"
    }
    </code></pre>
</section>
<section>
    <h2>Modules</h2>
    <p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a
        module. Conversely, a file without any top-level import or export declarations is treated as a script whose
        contents are available in the global scope (and therefore to modules as well).</p>
    <p>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the
        export keyword.</p>
</section>
<section>
    <pre><code data-trim data-noescape>
    class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 && numberRegexp.test(s);
        }
    }
    export { ZipCodeValidator };
    export { ZipCodeValidator as mainValidator };
    </code></pre>
    <pre><code data-trim data-noescape>import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";</code></pre>
    <pre><code data-trim data-noescape>
    import * as validator from "./ZipCodeValidator";
    let myValidator = new validator.ZipCodeValidator();
    Import a module for side-effects only
    </code></pre>
</section>
<section>
    <pre><code data-trim data-noescape>
        //ZipCodeValidator.ts
        export default class ZipCodeValidator {
            static numberRegexp = /^[0-9]+$/;
            isAcceptable(s: string) {
                return s.length === 5 && 
                    ZipCodeValidator.numberRegexp.test(s);
            }
        }
        //Test.ts
        import validator from "./ZipCodeValidator";
        let myValidator = new validator();
    </code></pre>
</section>
<section>
    <h2>export = und import = require()</h2>
    <ul style="font-size: 30px;">
        <li>CommonJS und AMD exportieren ein Objekt, das alle exports eines Modules enthält.</li>
        <li>Das export object kann durch ein beliebiges Objekt ersetzt werden. Default exports sind als Ersatz für
            dieses
            Verhalten gedacht. </li>
        <li>TypeScript unterstützt export = um diesen traditionellen CommonJS and AMD Workflow zu
            unterstützen.</li>
        <li>The export = gibt ein einzelnes Objeckt an, das exportiert wird. Exportiert werden können: class,
            interface,
            namespace, function, oder enum.</li>
        <li>Wenn der TypeScript-specific export = benutzt wird, muss der Import des Modules mit = require("module")
            erfolgen.</li>
    </ul>
</section>
<section>
    <h2>Arbeiten mit anderen JavaScript Libraries</h2>
    <p> Um die Struktur der Library zu beschreiben, die nicht in TypeScript geschrieben wurde, müssen wir die API der
        Library definieren.
        Deklarationen, die keine Implementierung definieren, sind “ambient”. Diese APIs sind in d.ts files definiert,
        ähnlich wie .h Dateien in C++.
    </p>
</section>
<section>
    <h2>Namespaces</h2>
    <p>Ähnlich zu packages in Java oder C++.</p>
    <pre><code data-trim data-noescape>
        namespace Shapes {
            export namespace Polygons {
                export class Triangle { }
                export class Square { }
            }
        }
        import polygons = Shapes.Polygons;
        let sq = new polygons.Square();
        // Same as 'new Shapes.Polygons.Square()
    </code></pre>
</section>
<!-- <section>
    <h2>Namespaces and Modules</h2>
</section> -->
<!-- <section>
    <h2>Module Resolution</h2>
</section> -->
<section>
    <h2>Declaration Merging</h2>
    <style>
        td {
            text-align: center !important;
        }
    </style>
    <table>
        <tr>
            <th>Declaration Type</th>
            <th>Namespace</th>
            <th>Type</th>
            <th>Value</th>
        </tr>
        <tr>
            <td>Namespace</td>
            <td>X</td>
            <td></td>
            <td>X</td>
        </tr>
        <tr>
            <td>Class</td>
            <td></td>
            <td>X</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Enum</td>
            <td></td>
            <td>X</td>
            <td>X</td>
        </tr>
        <tr>
            <td>Interface</td>
            <td></td>
            <td>X</td>
            <td></td>
        </tr>
        <tr>
            <td>Type Alias</td>
            <td></td>
            <td>X</td>
            <td></td>
        </tr>
        <tr>
            <td>Function</td>
            <td></td>
            <td></td>
            <td>X</td>
        </tr>
        <tr>
            <td>Variable</td>
            <td></td>
            <td></td>
            <td>X</td>
        </tr>
    </table>
</section>
<section>
    <h2>Declaration Merging</h2>
    <pre><code data-trim data-noescape>
    interface Box {
        height: number;
        width: number;
    }
    
    interface Box {
        scale: number;
    }
    
    let box: Box = {height: 5, width: 6, scale: 10};
</code></pre>
</section>
<section>
    <h2>Decorators</h2>
    <pre><code>tsc --target ES5 --experimentalDecorators</code></pre>
    <pre><code data-trim data-noescape>
        @classDecorator 
        class Greeter {</code></pre>
    <pre><code data-trim data-noescape>
            class C {
                @f()
                @g()
                method(param: string) {</code></pre>
</section>
<section>
    <h2>Mixins</h2>
    <p>aka Traits in Skala.</p>
    <pre><code data-trim data-noescape>
        // Activatable Mixin
        class Activatable {
            isActive: boolean;
            activate() {
                this.isActive = true;
            }
            deactivate() {
                this.isActive = false;
            }
        } 
        class SmartObject implements Activatable {
    </code></pre>

</section>
<!-- <section>
    <h2>Triple-Slash Directives</h2>
    <p>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are
        used as compiler directives.</p>
</section> -->
<!-- <section>
    <h2>Type Checking JavaScript Files</h2>
</section> -->

<section>
    <h2>Map</h2>
    <pre><code data-trim data-noescape>
            const resultArray = [];
            const initialArray = [1, 2, 3, 4];
            for (let index = 0; index &lt; initialArray.length; index++) {
                resultArray[index] = initialArray[index] * initialArray[index];
            }
    </code></pre>
    <pre><code data-trim data-noescape>
            const multiply = (value: number) => value * value;
            console.log([1, 2, 3, 4].map(multiply));
    </code></pre>
</section>


<section>
    <h2>Filter</h2>
    <pre><code data-trim data-noescape style="font-size: 20px" class="typescript">
        const initialArray = [1, 2, 3, 4];
        for (let index = 0; index &lt; initialArray.length; index++) {
            if (initialArray[index] * 100 > 200) {
                resultArray.push(initialArray[index] * 100);
                // resultArray[index] = initialArray[index] * 100;
            }
        }
    </code></pre>
    <pre><code data-trim data-noescape style="font-size: 20px" class="typescript">
        console.log([1, 2, 3, 4].map(num => num * 100).filter(value => value > 200));
    </code></pre>
</section>

<section>
    <h2>Reduce</h2>
    <pre><code data-trim data-noescape>
            let result = 0;
            [1, 2, 3, 4].forEach(number => result += number);
    </code></pre>
    <pre><code data-trim data-noescape>
            // Pure Function
            const reducer = (sum: number, value: number) => sum += value;
            console.log([1, 2, 3, 4].reduce(reducer, 0));
    </code></pre>
</section>