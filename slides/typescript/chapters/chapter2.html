<!-- <aside style="position: absolute; top: 0px; right: 0px;" data-controls-layout>TypeScript Handy On</aside> -->
<section>
    <h1>TypeScript Basics</h1>
</section>
<section>
    <h2>Exercise 1 & 2</h2>
    <p>Setup TypeScript and your first TypeScript project</p>
    <aside class="notes">
        Show package.json<br>
        package.json corresponds to pom.xml of maven<br>
        node_modules corresponds to .m2 folder of maven<br>
        Show tsconfig.json: show target says es5 and module says es2015 as result targets
    </aside>
</section>
</section>
<section>
    <h2>Basic Types: Boolean</h2>
    <pre><code>let isDone: boolean = false;</code></pre>
</section>
<section>
    <h2>Basic Types: Number</h2>
    <pre><code  class="typescript" data-trim data-noescape>
        let decimal: number = 6; 
        let hex: number = 0xf00d; 
        let binary: number = 0b1010; 
        let octal: number = 0o744;
    </code></pre>
</section>
<section>
    <h2>Basic Types: String</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let color: string = "blue";
        color = 'red';
        let age: number = 37;
        let sentence: string = `Hello, my name is ${ fullName }.
        I'll be ${ age + 1 } years old next month.`;
    </code></pre>
</section>
<section>
    <h2>Basic Types: Array</h2>
    <pre><code>let list: number[] = [1, 2, 3];</code></pre>
    <pre><code class="typescript">let list: Array&lt;number> = [1, 2, 3];</code></pre>
</section>
<section>
    <h2>Basic Types: Tuple</h2>
    <pre><code data-trim data-noescape>
        let x: [string, number, number];
        // Initialize it
        x = ['hello', 10, 5]; // OK
        // Initialize it incorrectly
        x = [10, 'hello', 5]; // Error
    </code></pre>
</section>
<section>
    <h2>Basic Types: Enum</h2>
    <pre><code data-trim data-noescape>
        enum Color {Red, Green, Blue}
        let c: Color = Color.Green;
    </code></pre>
    <aside class="notes">
        Tuple type: fixed types in an array with different content (could be used for string-number pairs)
    </aside>
</section>
</section>
<section>
    <h2>Basic Types: Any</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let list: any[] = [1, true, "free"];
    </code></pre>
</section>
<section>
    <h2>Basic Types: Unknown</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let someValue: unknown = "this is a string";
        let someValue: unknown = 999;
        if (typeof someValue === 'string') {
            let strLength: number = (&lt;string>someValue).length;
        } else {
            console.error('wrong type');
        }
    </code></pre>
</section>
<section>
    <h2>Basic Types: Void</h2>
    <pre><code class="typescript" data-trim data-noescape>
        function warnUser(): void {
            console.log("This is my warning message");
        }
    </code></pre>
</section>
<section>
    <h2>Basic Types: Never</h2>
    <pre><code class="typescript" data-trim data-noescape>
        function error(message: string): never {
            throw new Error(message);
        }
        function blockthread(message: string): never {
            while(true){
                
            }
        }
    </code></pre>
</section>
</section>
<section>
    <h2>Basic Types: Undefined, Null</h2>
    <pre><code class="typescript" data-trim data-noescape>
        function doSomething(param: string | null | undefined): void
    </code></pre>
    <h4>Object</h4>
    <p>Object ist ein nicht primitiver Typ, also alles was nicht number, string, boolean,
        symbol, null, oder undefined ist.</p>
    <pre><code class="typescript" data-trim data-noescape>
        function create(o: object | null): void;
    </code></pre>
    <pre><code class="typescript" data-trim data-noescape>
        function create(o: {} | null): void;
    </code></pre>
</section>
<section>
    <h2>Type Assertions</h2>
    <pre><code>let strLength: number = (&lt;string>someValue).length;</code></pre>
    <pre><code>let strLength: number = (someValue as string).length;</code></pre>
</section>
<section>
    <h2>Undefined & null Pr√ºfung</h2>
    <pre><code class="typescript" data-trim data-noescape>
        function nullcheck(param: { property: string }) {
            if(param !== null && typeof param !== 'undefined'){
                if(param.property !== null && 
                    typeof param.property !== 'undefined'){
                        // NOOOOO
                }
            }
            if(param && param.property){
                // string
            }
            if(!!(param && param.property)){
                // boolean
            }
        }
    </code></pre>
    <p>!! Operator: "bang, bang you're boolean" </p>
</section>
<section>
    <h2>Variable Declarations 1</h2>
    <pre><code>var a = 10; // the old way</code></pre>
    <pre><code data-trim data-noescape>
        let greeting = 'hello';
        greeting = 'bye';
    </code></pre>
    <p>Rule of thumb: Use let instead of var.</p>
</section>
<section>
    <h2>Variable Declarations 2</h2>
    <pre><code data-trim data-noescape>
        const greeting = 'hello';
        greeting = 'bye'; // error
    </code></pre>
    <p>Immutability for primitive data types.</p>
    <pre><code data-trim data-noescape>
        const greeting = { text: 'hello'} ;
        greeting.text = 'bye'; // mutating sub properties is allowed (e.g. content of arrays and objects)
        console.log(greeting); // { text: 'bye' }
    </code></pre>
    <aside class="notes">
        const is like final in JAVA.<br>
        see readonly for true immutability
    </aside>
</section>
<section>
    <h2>Variable Scoping</h2>
    <ul>
        <li>var: function scope</li>
        <li>const & let: block scope</li>
    </ul>
    <aside class="notes">See examples: chapter2_variable_scoping.ts</aside>
</section>
<section>
    <p>Where is the problem?</p>
    <pre><code data-trim data-noescape>
        function sumMatrix(matrix: number[][]) {
            var sum = 0;
            for (var i = 0; i &lt; matrix.length; i++) {
                var currentRow = matrix[i];
                for (var i = 0; i &lt; currentRow.length; i++) {
                    sum += currentRow[i];
                }
            }
            return sum;
        }
    </code></pre>
    <p class="fragment">Use let instead var for i.</p>
</section>
<section>
    <h2>Destructuring Arrays</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let [first, ...rest] = [1, 2, 3, 4];
        console.log(first); // outputs 1
        console.log(rest); // outputs [ 2, 3, 4 ]
    </code></pre>
    <h2>Destructuring Objects</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let o = {
            a: "foo",
            b: 12,
            c: "bar"
        };
        let { a, b } = o;
    </code></pre>
    <aside class="notes">
        Usefull to extract values from a tuple
    </aside>
</section>
<section>
    <h2>Spread Operator</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let first = [1, 2];
        let second = [3, 4];
        let bothPlus = [0, ...first, ...second, 5];
    </code></pre>
    <p class="fragment">[0, 1, 2, 3, 4, 5]</p>
</section>
<section>
    <h2>Interfaces</h2>
    <p>Explicitly defined types</p>
    <pre><code data-trim data-noescape class="typescript">
        function printLabel(labelledObj: { label: string }) {
            console.log(labelledObj.label);
        }
        let myObj = {size: 10, label: "Size 10 Object"};
        printLabel(myObj);
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
        interface LabelledValue {
            label: string;
            optional?: boolean; // optional parameter
        }
        
        function printLabel(labelledObj: LabelledValue) {
            console.log(labelledObj.label);
        }
        let myObj = {size: 10, label: "Size 10 Object"};
        printLabel(myObj);
    </code></pre>
    <p>What does the transpiler do with interfaces?</p>
    <aside class="notes">
        Answer: interfaces will not be transpiles to es5 -> they disappear!
    </aside>
</section>
<section>
    <h2>Readonly</h2>
    <ul>
        <li>Variables: const</li>
        <li>Properties: readonly</li>
        <li>ReadonlyArray:</li>
    </ul>
    <pre><code class="typescript" data-trim data-noescape>
        interface LabelledValue {
            label: string;
            readonly generalInfo: string;
        }

        let a: number[] = [1, 2, 3, 4];
        let ro: ReadonlyArray&lt;number> = a;
        ro[0] = 12; // error!
        ro.push(5); // error!
        ro.length = 100; // error!
        a = ro; // error!
    </code></pre>
</section>
<section>
    <h2>Classes</h2>
    <ul>
        <li>Can be used as type if there is a constructor function in the type.</li>
        <li>Constructor parameters will automatically be transformed to properties with an access modifier or readonly.</li>
    </ul>
    <pre><code class="typescript" data-trim data-noescape>
        class DigitalClock implements ClockInterface {
            constructor(public h: number, public m: number) {}
            tick() {
                console.log('beep beep');
            }
        }
    </code></pre>
    <pre><code class="typescript" data-trim data-noescape>
        get fullName(): string {
            return this._fullName;
        }
        set fullName(newName: string) {
            if (passcode && passcode == "secret passcode") {
                this._fullName = newName;
            }
        }
        employee.fullName = "Bob Smith";
        console.log(employee.fullName);
    </code></pre>
</section>
<section>
    <h2>Functions</h2>
    <p>Difference to JavaScript: Signature</p>
    <pre><code class="typescript" data-trim data-noescape>
        let myAdd0: (x: number, y: number) => number = (x, y) => {
            return x + y;
        };

        function myAdd1(x: number, y: number): number {
            return x + y;
        }
        type functionType = (x: number, y: number) => number;
        let myAdd2: functionType = (x, y) => {
            return x + y;
        };
    </code></pre>
    <aside class="notes">
        First is not so good because it is badly readable and the definition of the signature is not reusable. Second and third example are good.
    </aside>
</section>
<section>
    <p>Optional Parameter:</p>
    <pre><code class="typescript" data-trim data-noescape>
        function buildName(firstName: string, lastName?: string) {}
    </code></pre>
    <p>Default Parameter:</p>
    <pre><code class="typescript" data-trim data-noescape>
        function buildName(firstName: string, lastName = 'Smith') {}
    </code></pre>
    <p>Rest Parameter:</p>
    <pre><code class="typescript" data-trim data-noescape>
        function buildName(firstName: string, ...restOfName: string[]) {}
    </code></pre>
</section>
<section>
    <h2>this and arrow functions</h2>
    <p>In JavaScript <i>this</i> is a variable that will be created if a function is executed.</p>
    <p>Arrow functions will create <i>this</i> where the function will be created.</p>
</section>
<section>
    <h2>Generics</h2>
    <p>Function Signature</p>
    <pre><code class="typescript" data-trim data-noescape>
        function create&lt;T>(c: {new(): T; }): T {}
    </code></pre>
    <p>Function Signature</p>
    <pre><code class="typescript" data-trim data-noescape>
        function getProperty&lt;T, K extends keyof T>(obj: T, key: K) {}
    </code></pre>
    <p>Generic Classes</p>
    <pre><code class="typescript" data-trim data-noescape>
        class GenericNumber&lt;T> {
            zeroValue: T;
            add: (x: T, y: T) => T;
        }
    </code></pre>
</section>
<section>
    <h2>Enums</h2>
    <p>Numeric Enums</p>
    <pre><code class="typescript" data-trim data-noescape>
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }
    </code></pre>
    <p>String Enums</p>
    <pre><code class="typescript" data-trim data-noescape>
        enum Direction {
            Up = "UP",
            Down = "DOWN",
            Left = "LEFT",
            Right = "RIGHT",
        }
    </code></pre>
</section>
<section>
    <h2>Type Inference</h2>
    <p>Best common type</p>
    <pre><code>let x = [0, 1, null];</code></pre>
    <pre><code>number | null</code></pre>
    <p>Contextual Type</p>
    <pre><code class="typescript" data-trim data-noescape>
        function createZoo(): Animal[] {
            return [new Rhino(), new Elephant(), new Snake()];
        }
    </code></pre>
    <pre><code>Animal</code></pre>
</section>
<section>
    <h2>Type Compatibility (1)</h2>
    <p>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types
        based solely on their members. This is in contrast with nominal typing. Consider the following code:</p>
    <pre><code class="typescript" data-trim data-noescape>
        interface Named {
            name: string;
        }
    
        class Person {
            name: string;
        }
        let p: Named;
        // OK, because of structural typing
        p = new Person();
    </code></pre>
</section>
<section>
    <h2>Type Compatibility (2)</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let x = (a: number) => 0;
        let y = (b: number, s: string) => 0;
        
        y = x; // OK
        x = y; // Error
    </code></pre>
</section>
<section>
    <h2>Advanced Types</h2>
    <p>Union Types</p>
    <pre><code class="typescript" data-trim data-noescape>
        function padLeft(value: string, padding: string | number) {}
    </code></pre>
    <p>Intersection</p>
    <pre><code class="typescript" data-trim data-noescape>
        function extend&lt;T, U>(first: T, second: U): T & U {}
    </code></pre>
    <p>Type Guards</p>
    <pre><code class="typescript" data-trim data-noescape>
    function isFish(pet: Fish | Bird): pet is Fish {
        return (&lt;Fish>pet).swim !== undefined;
    }
    </code></pre>
</section>
<section>
    <h2>Iterators und Generators</h2>
    <p>values: for..of (Iterator Types. Unterschiedlicher Compiler-Output mit ES3 und ES5)</p>
    <p>keys: for..in Objects und Iterator Types</p>
    <pre><code class="typescript" data-trim data-noescape>
    const list4to6 = ["4", "5", "6"];
    for (let i in list4to6) {
        console.log(i); // "0", "1", "2" (index: always of type string)
    }
    for (let i of list4to6) {
        console.log(i); // "4", "5", "6" (items: always of type string)
    }
    </code></pre>
</section>
<section>
    <h2>Namespaces</h2>
    <p>Similar to packages in Java or C++.</p>
    <pre><code class="typescript" data-trim data-noescape>
        namespace Shapes {
            export namespace Polygons {
                export class Triangle { }
                export class Square { }
            }
        }
        import polygons = Shapes.Polygons;
        let sq = new polygons.Square();
        // Same as 'new Shapes.Polygons.Square()
    </code></pre>
</section>
<section>
    <h2>Declaration Merging</h2>
    <pre><code class="typescript" data-trim data-noescape>
    interface Box {
        height: number;
        width: number;
    }
    
    interface Box {
        scale: number;
    }
    
    let box: Box = {height: 5, width: 6, scale: 10};
</code></pre>
</section>
<section>
    <h2>Map</h2>
    <pre><code data-trim data-noescape class="typescript">
    const resultArray = [];
    const initialArray = [1, 2, 3, 4];
    for (let index = 0; index &lt; initialArray.length; index++) {
        resultArray[index] = initialArray[index] * initialArray[index];
    }
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
    const multiply = (value: number) => value * value;
    console.log([1, 2, 3, 4].map(multiply));
    </code></pre>
</section>
<section>
    <h2>Filter</h2>
    <pre><code data-trim data-noescape style="font-size: 20px" class="typescript">
        const initialArray = [1, 2, 3, 4];
        for (let index = 0; index &lt; initialArray.length; index++) {
            if (initialArray[index] * 100 > 200) {
                resultArray.push(initialArray[index] * 100);
                // resultArray[index] = initialArray[index] * 100;
            }
        }
    </code></pre>
    <pre><code data-trim data-noescape style="font-size: 20px" class="typescript">
        console.log([1, 2, 3, 4].map(num => num * 100).filter(value => value > 200));
    </code></pre>
</section>
<section>
    <h2>Reduce</h2>
    <pre><code data-trim data-noescape class="typescript">
    let result = 0;
    [1, 2, 3, 4].forEach(number => result += number);
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
    // Pure Function
    const reducer = (sum: number, value: number) => sum += value;
    console.log([1, 2, 3, 4].reduce(reducer, 0));
    </code></pre>
</section>