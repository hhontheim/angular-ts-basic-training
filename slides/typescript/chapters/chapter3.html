<section>
    <h1>Promises <br>& <br>Async / Await</h1>
</section>
<section>
    <h2>Scenario</h2>
    <p class="fragment">
        An application calls an API for data, processes it and presents it in a nicely formatted way.
    </p>
    <p class="fragment">
        Problem: When will the API return the requested data?
    </p>
    <p class="fragment">
        Answer: When the API returns the data. We don't know!
    </p>
    <p class="fragment">
        Solution: We wait for the data to be returnes -> Promises
    </p>
    <aside class="notes">
        If the application tries to process the data before it is returnes by the API there will be an error or an empty website.
        If we return a Promise we can ensure that the data will be processed after the API returned it to the application successfully or handle error cases.
    </aside>
</section>
<section>
    <p>
        Promise<br>
        =
        <br>
        possible result of an asynchronous operation
    </p>
    <aside class="notes">
        like a placeholder = object you can append callbacks to it<br>
        Through Promisies we are able to wait for a specific code part to be executed first before an other part gets executed.
    </aside>
</section>
<section>
    <pre><code data-trim data-noescape>
    function success(result) {
        console.log("Audio file ready at URL: " + result);
    }
    
    function failure(error) {
        console.log("Error generating audio file: " + error);
    }
    
    // Without promise
    createAudioFileAsync(audioSettings, success, failure);

    // With promise
    createAudioFileAsync(audioSettings).then(success, failure);
    </code></pre>
    <p class="fragment">
        <code>then()</code> will be executed as recently as the function <code>createAudioFileAsync</code> returns.
    </p>
    <aside class="notes">
        multiple then() can be appended after each other -> They will be executed in that order they were appended.
    </aside>
</section>
<section>
    <h2>Promise Chaining</h2>
    <pre><code data-trim data-noescape>
    promiseFunction()
        .then(success1, failure1)
        .then(success2, failure2)
        .catch(failureCallback);
    </code></pre>
    <p>
        <h3>Important</h3>
        <ul>
            <li>Always return a result else the callback does not get the result of the previous Promise.</li>
            <li>If a <code>then()</code> throws an error the promise chain stops and looks for a catch() further in the chain.</li>
        </ul>
    </p>
    <aside class="notes">
        Execution order: 1. promiseFunction 2. success1()/failure1() 3. success2()/failure2()
    </aside>
</section>
<section>
    <h2>Create a Promise</h2>
    <pre><code data-trim data-noescape>
    new Promise( /* executor */ function(resolve, reject) { ... } );
    </code></pre>
    <p>
        Create a Promise for example to wrap an old API:
    </p>
    <pre><code data-trim data-noescape>
    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
    // alternative: Promise.resolve(setTimeout(resolve, ms));
    wait(10000)
        .then(() => saySomething("10 seconds"))
        .catch(failureCallback);
    </code></pre>
    <aside class="notes">
        A function with the arguments resolve and reject will be forwarded. The executor function will be immediately executed by the Promise implementation.
        The executor function initiate asynchronous work and when it is done it will call the resolve or reject function.
        If there is an error in the executor function the Promise and so its return value will be rejected.
    </aside>
</section>
<section>
    <pre><code data-trim data-noescape>
    // callback hell
    doSomething(function(result) {
        doSomethingElse(result, function(newResult) {
            doThirdThing(newResult, function(finalResult) {
                console.log('Got the final result: ' + finalResult);
            }, failureCallback);
        }, failureCallback);
    }, failureCallback);
    </code></pre>
</section>
<section>
    <pre><code data-trim data-noescape>
    // promise chain
    doSomething()
    .then(function(result) {
        return doSomethingElse(result);
    })
    .then(function(newResult) {
        return doThirdThing(newResult);
    })
    .then(function(finalResult) {
        console.log('Got the final result: ' + finalResult);
    })
    .catch(failureCallback);
    </code></pre>
</section>
<section>
    <pre><code data-trim data-noescape>
    // promise chain with arrow functions
    doSomething()
        .then(result => doSomethingElse(result))
        .then(newResult => doThirdThing(newResult))
        .then(finalResult => {
            console.log(`Got the final result: ${finalResult}`);
        })
        .catch(failureCallback);
    </code></pre>
</section>
<section>
    <h2>Wait for us!</h2>
    <pre><code data-trim data-noescape class="typescript">
    let p1 = Promise.resolve(3);
    let p2 = 1337;
    let p3 = new Promise((resolve, reject) => {
        setTimeout(resolve, 100, 'foo');
    });
    
    Promise.all([p1, p2, p3])
    .then(values => {
        console.log(values);
    });
    </code></pre>
    <pre class="fragment"><code data-trim data-noescape class="typescript">
    // [3, 1337, "foo"]
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Promises will be processed in parallel.</li>
            <li>Returns a Promise that will be resolved when all arguments have been resolved or rejected or if any argument contains no Promise. It will be rejected with the first rejection return value.</li>
        </ul>
    </aside>
</section>
<section>
    <h2>First wins it all!</h2>
    <pre><code data-trim data-noescape class="typescript">
    let promise1 = new Promise((resolve, reject) => {
        setTimeout(resolve, 500, 'one');
    });
    
    let promise2 = new Promise((resolve, reject) => {
        setTimeout(resolve, 100, 'two');
    });
    
    Promise.race([promise1, promise2]).then(function(value) {
        console.log(value);
    });
    </code></pre>
    <pre class="fragment"><code data-trim data-noescape class="typescript">
    // Both resolve, but promise2 is faster
    // expected output: "two"
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Promises will be processed in parallel.</li>
        </ul>
    </aside>
</section>
<section>
    <h2>Do's</h2>
    <ul>
        <li>Correct function chaining: Always return the created promise!</li>
        <li>Do only chain Promises and do not nest them!</li>
        <li>Always end a Promise chain with a catch()!</li>
    </ul>
</section>
<section>
    <h2>Timing</h2>
    <pre><code data-trim data-noescape class="typescript">
    Promise.resolve().then(() => console.log(2));
    console.log(1);
    </code></pre>
    <pre class="fragment"><code data-trim data-noescape class="typescript">
    // expected output:  1, 2
    </code></pre>
    <p class="fragment">
        The forwarded function will be layed on the micro tasks queue -> the function will be executed later, because the queue will be executed at the end of the current execution of the JavaScript Event Loop.
    </p>
</section>
<section>
    <h2>Sources for Promises</h2>
    <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Promise</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">MDN Using Promises</a></li>
    </ul>
</section>
<section>
    <h2>Exercise: Promises</h2>
    <p>Create the console output using Promise chaining.</p>
    <pre><code data-trim data-noescape class="typescript">
    // Console output
    Initial
    Do that
    Do this, no matter what happened before
    </code></pre>
    <ul>
        <li>Output "Initial" will be logged in the created Promise.</li>
        <li>There is a error case as second chain element that normally logs "Do this" but because of the error is logs "Do that".</li>
    </ul>
</section>
<section>
    <h2>Solution for Exercise: Promises</h2>
    <pre><code data-trim data-noescape class="typescript">
    new Promise((resolve, reject) => {
        console.log('Initial');
        resolve();
    })
    .then(() => {
        throw new Error('Something failed');
            
        console.log('Do this');
    })
    .catch(() => {
        console.log('Do that');
    })
    .then(() => {
        console.log('Do this, no matter what happened before');
    });
    </code></pre>
</section>
<section>
    <h3>Async / Await</h3>
    <ul>
        <li>Introduction with ES2017</li>
        <li>An <code>async</code> function declaration defines an asynchronous function. It can contain an <code>await</code> expression that interrups the execution of the <code>async</code> function and waits for the resolution of the Promise and the continues the execution of the <code>async</code> function.</li>
        <li>Through <code>async</code>/<code>await</code> we can use Promises synchronously.</li>
    </ul>
</section>
<section>
    <h2>Refactoring the Promise chain with the async function</h2>
    <pre><code data-trim data-noescape>
    async function foo() {
        try {
            const result = await doSomething();
            const newResult = await doSomeThingElse(result);
            const finalResult = await doThirdThing(newResult);
            console.log(`Got the final result: ${finalResult}`);
        } catch(error) {
            failureCallback(error);
        }
    }
    </code></pre>
    <aside class="notes">
        <code>await</code> expression is only valid in an <code>async</code> function.
    </aside>
</section>
<section>
    <h2>Sources for Async / Await</h2>
    <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN Async Function</a></li>
    </ul>
</section>
<section>
    <h1>RxJS</h1>
    <!-- <p>
        5-10 most important functions of RxJS:
        <ul>
            <li>pipe(map, map)</li>
            <li>map</li>
            <li>switchMap, mergeMap, concatMap</li>
            <li>filter</li>
            <li>from, of, timer, interval</li>
            <li>combineLatest</li>
            <li>merge, zip</li>
        </ul>
    </p> -->
</section>
<section>
    <h2>What is RxJS?</h2>
    <p>
        <ul>
            <li>Reactive extensions for JavaScript</li>
            <li>Library for reactive programming using Observables that makes composing of asynchronous and event based code easier.</li>
            <li>Used patterns: Observer Pattern, Iterator Pattern, Functional Programming with collections</li>
        </ul>
    </p>
</section>
<section>
    <h2>Reactive Programming</h2>
    <p>
        "In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change. With this paradigm it is possible to express static (e.g., arrays) or dynamic (e.g., event emitters) data streams with ease, and also communicate that an inferred dependency within the associated execution model exists, which facilitates the automatic propagation of the changed data flow."
    </p>
    <p><a href="https://en.wikipedia.org/wiki/Reactive_programming">Wikipedia: Reactive Programming</a></p>
</section>
<section>
    <h2>Observer Pattern</h2>
    <ul>
        <li>An object (Subject) manages a list of dependent structures (Observers) and notifies them automatically at every status change of the object (publish-subscribe).</li>
        <li>Used for event driven software.</li>
    </ul>
    <aside class="notes">
        Source: https://en.wikipedia.org/wiki/Observer_pattern
    </aside>
</section>
<section>
    <h2>Iterator Pattern</h2>
    <p>
        Through an iterator an aggregated structure is sequential accessible without exposing its structure.
    </p>
    <aside class="notes">
        Through an iterator you can iterate both an array of numbers and an array of objects or strings.<br>
        Source: https://en.wikipedia.org/wiki/Iterator_pattern
    </aside>
</section>
<section>
    <h2>What does RxJS offer?</h2>
    <p>
        <ul>
            <li>Convert existing asynchronous code into Observables.</li>
            <li>Iterate through the values of a stream.</li>
            <li>Map values to different types.</li>
            <li>Filter streams.</li>
            <li>Concatenate multiple streams with each other.</li>
        </ul>
    </p>
</section>
<section>
    <h2>Create and listen!</h2>
    <pre><code data-trim data-noescape>
    import { of } from "rxjs";

    function next(val: number) {
        console.log(`next: ${val}`);
    }
    function error() {
        console.log("error!");
    }
    function completed() {
        console.log("completed!");
    }
    
    of(1, 2, 3, 4).subscribe(next, error, completed);
    </code></pre>
</section>
<section>
    <h2>Hot & Cold Obervables (1)</h2>
    <h3>Cold Observable</h3>
    <ul>
        <li>The data producer is created by the observable itself</li>
        <li>Multiple subscribers: the whole data stream is re-emitted for each subscriber</li>
        <li>Always emits</li>
        <li>Making a cold observable hot using the <code>share</code> operator</li>
        <li>Examples: observables created using the <code>of</code>, <code>from</code>, <code>range</code>, <code>interval</code> and <code>timer</code> operators</li>
    </ul>
    <aside class="notes">
        multiple subscribers: Each subscriber becomes independent and gets its own stream of data<br>
        data is not being produced until the observable is subscribed to.
    </aside>
</section>
<section>
    <h2>Hot & Cold Obervables (2)</h2>
    <h3>Hot Observable</h3>
    <ul>
        <li>The data producer is outside of the observable itself</li>
        <li>These observables are closing over external data producers</li>
        <li>The data is being produced regardless of if there’s a subscriber or not.</li>
        <li>Examples: <code>fromEvent</code> operator for user events (clicks, mouse moves,…) or WebSocket events</li>
    </ul>
    <aside class="notes">
        If there’s no subscriber when the data is being produced, the data is simply lost.
    </aside>
</section>
<section>
    <h2><code>map()</code> operator</h2>
    <pre><code data-trim data-noescape>
    map(project: Function, thisArg?: any): Observable
    </code></pre>
    <p>
        Apply projection with each value from source.
    </p>
</section>
<section>
    <h2><code>filter()</code> operator</h2>
    <pre><code data-trim data-noescape>
    filter(condition: Function, thisArg?: any): Observable
    </code></pre>
    <p>
        Emit values that pass the provided condition.
    </p>
</section>
<section>
    <h2><code>pipe()</code> operator</h2>
    <pre><code data-trim data-noescape>
    pipe(functions: ...*): Observable
    </code></pre>
    <p>
        Operator chaining<br>
        Like a recipe (Set of instructions that produce values) nennen. The recipe will be executed only if subcribe() will be called on it.
    </p>
</section>
<section>
    <h2><code>concat()</code> operator</h2>
    <pre><code data-trim data-noescape>
    concat(observables: ...*): Observable
    </code></pre>
    <p>
        Subscribe to observables in order as previous completes, emit values.
    </p>
</section>
<section>
    <h2><code>flatMap()</code> / <code>mergeMap()</code> operators</h2>
    <pre><code data-trim data-noescape>
    mergeMap(project: function: Observable, resultSelector: function: any, concurrent: number): Observable
    </code></pre>
    <p>
        Flattens an inner observable.
    </p>
</section>
<section>
    <h2><code>catchError()</code> operator</h2>
    <pre><code data-trim data-noescape>
    catchError(project: function): Observable
    </code></pre>
    <p>
        Gracefully handle errors in an observable sequence.<br>
        <br>
        Important: Always return an Observable!
    </p>
</section>
<section>
    <h2><code>retry()</code> & <code>retryWhen()</code> operator</h2>
    <pre><code class="typescript" data-trim data-noescape style="font-size: 20px">
    retry(count: number): Observable
    retryWhen(receives: (errors: Observable) => Observable, the: scheduler): Observable
    </code></pre>
    <p>
        If origin observable throws an error -> retry count times after throwing error or retryWhen(custom criteria)<br>
        <br>
        Caution: Do not use retry for authentication requests or risk blocking user account
    </p>
    <aside class="notes">
        Do not retry authentication requests, since these should only be initiated by user action.
        We don't want to lock out user accounts with repeated login requests that the user has not initiated.
    </aside>
</section>
<section>
    <h2>Exercise: RxJS</h2>
    <p>
        An API returns natural numbers in ascending order.<br>
        Add up the powers of the first 3 even numbers and return the values.<br>
        See additional operators <code>reduce()</code> und <code>take()</code>
    </p>
</section>
<section>
    <h2>Sources</h2>
    <ul>
        <li>https://de.wikipedia.org/wiki/Reaktive_Programmierung</li>
        <li>https://rxjs-dev.firebaseapp.com/</li>
        <li>https://angular.io/guide/rx-library</li>
        <li>https://www.learnrxjs.io/</li>
    </ul>
</section>
