<section>
    <h2>Lets add some content..</h2>
    <ul>
        <li>Barrel TS</li>
        <li>Rxjs @angular</li>
        <li>Dependency Injection</li>
        <li>Routing parameters</li>
        <li>Template Binding and Rendering</li>
        <li>Dynamic html content</li>
        <li>Services</li>
    </ul>
</section>
<section>
    <h2>Barrel</h2>
    <ul>
        <li>index.ts file exports folder content.</li>
        <li>import paths are shorter and easier</li>
        <li>imports from one module appear in one line</li>
        <li>recommended for the core and shared module</li>
    </ul>
</section>
<section>
    <h2>RXJS</h2>
    <ul>
        <li>Subject, BehaviorSubject, AsyncSubject</li>
        <li>Subjects are Observables and Subcribers.</li>
        <li>Are useful to handle mock data or local state of a service.</li>
        <li>subject.asObservable</li>
    </ul>
</section>
<section>
    <h2>Dependency Injection</h2>
    <p>You can configure injectors with providers at different levels of your app, by setting a metadata value in one
        of
        three places: </p>
    <ul>
        <li>In the @Injectable() decorator for the service itself.</li>
        <li>In the @NgModule() decorator for an NgModule.</li>
        <li>In the @Component() decorator for a component.</li>
    </ul>
    <p>
        Injectors are inherited, which means that if a given injector can't resolve a dependency, it asks the parent
        injector to resolve it.
    </p>
    <pre><code> [{ provide: Logger, useClass: Logger }]</code></pre>

    <pre><code data-trim>
    import { InjectionToken } from '@angular/core';
    export const APP_CONFIG = new InjectionToken&lt;AppConfig>('app.config');
    </code></pre>
    <p><a target="_blank" href="https://angular.io/guide/dependency-injection-providers">DI Providers</a></p>
    <p><a target="_blank" href="https://angular.io/guide/hierarchical-dependency-injection">DI Hierarchy</a></p>
</section>

<section>
    <h2>DI decorators</h2>
    <ul>
        <li>forwardRef</li>
        <p>Async Injection</p>
        <li>@Optional</li>
        <li>@Self</li>
        <li>@SkipSelf</li>
        <li>@HostListener('mouseenter')</li>
        <li>@Host</li>
        <p>Stop Injector bubbling. Checks viewProviders instead of providers. Element Injectors only.</p>
    </ul>

</section>

<section>
    <p>Two Loggers</p>
    <pre><code data-trim>
    [ NewLogger,
    { provide: OldLogger, useClass: NewLogger}]
    ]</code></pre>
    <p>One Logger</p>
    <pre><code data-trim>
    [ NewLogger,
    { provide: OldLogger, useExisting: NewLogger}]
    ]</code></pre>
</section>

<section>
    <h2>Value providers</h2>
    <p> An object in the shape of the logger service</p>
    <pre><code data-trim class="typescript">
    export function SilentLoggerFn() {}

    const silentLogger = {
        logs: ['Silent logger says "Shhhhh!". Provided via "useValue"'],
        log: SilentLoggerFn
    };

    [{ provide: Logger, useValue: silentLogger }]
</code></pre>
</section>

<section>
    <h2>Factory providers</h2>
    <pre><code data-trim class="typescript">
    constructor(
        private logger: Logger,
        private isAuthorized: boolean) { }

    let heroServiceFactory = (logger: Logger, userService: UserService) => {
        return new HeroService(logger, userService.user.isAuthorized);
    };

    export let heroServiceProvider =
    { provide: HeroService,
        useFactory: heroServiceFactory,
        deps: [Logger, UserService]
    };
    </code></pre>
</section>

<section>
    <h2>Routes with params</h2>
    <pre><code class="typescript"> [routerLink]="[{outlets: { secondary: ['safe', safe.id] }  }]</code></pre>
    <pre><code data-trim class="typescript">  constructor(
            private activatedRoute: ActivatedRoute,
            private service: SafeService
            ) { }
        ...
        this.activatedRoute.paramMap
        </code></pre>
    <pre><code class="typescript"> params.get('id')</code></pre>
    <pre><code class="typescript"> 
        {
            path: 'safe/:id',
            component: SafeComponent,
            outlet: 'secondary'
        },
    </code></pre>
</section>
<section>
    <h2>*ngFor, async, {{}}</h2>
    <ul>
        <li>let item of items</li>
        <li>{{ variable }}</li>
        <li>observable | async</li>
    </ul>
</section>
<section>
    <h2>Services</h2>
    <a href="https://angular.io/guide/architecture-services" target="_blank">Docs</a>
    <pre><code data-trim class="typescript" style="font-size: 18px">
            @Injectable()
            class UsefulService {
            }
            
            @Injectable()
            class NeedsService {
              constructor(public service: UsefulService) {}
            }
            
            const injector = ReflectiveInjector.resolveAndCreate([NeedsService, UsefulService]);
            expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
    </code></pre>
    <ul>
        <li></li>
    </ul>
</section>
<section>
    <h2>Now Exercise 6</h2>
</section>
<section>
    <h2>Recap</h2>
    <ul>
        <li class="fragment">How do we tell the browser with angular, that data changes?</li>
        <li class="fragment">What is one way binding?</li>
        <li class="fragment">What is *ngFor used for?</li>
        <li class="fragment">What is DI? How does it work?</li>
        <li class="fragment">...</li>
    </ul>
</section>